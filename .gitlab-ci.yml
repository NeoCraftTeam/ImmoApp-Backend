stages:
  - prepare
  - quality
  - build_and_test # Build + Test en parall√®le
  - deploy
  - smoke_test # V√©rification post-d√©ploiement
  - notify
  - cleanup

variables:
  APP_IMAGE: $CI_REGISTRY_IMAGE/app
  IMAGE_TAG: $CI_COMMIT_REF_SLUG
  CI_IMAGE: keyhome-ci:$CI_COMMIT_SHORT_SHA

default:
  tags:
    - self-hosted-shell

# --- ETAPE 0 : BUILD IMAGE CI (une seule fois) ---
prepare_ci_image:
  stage: prepare
  script:
    - |
      docker build -t $CI_IMAGE -f - . <<'DOCKERFILE'
      FROM php:8.4-cli-alpine
      RUN apk add --no-cache git libzip-dev icu-dev postgresql-dev libpng-dev oniguruma-dev gettext-dev freetype-dev libjpeg-turbo-dev libwebp-dev $PHPIZE_DEPS \
        && docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp \
        && docker-php-ext-install bcmath intl pdo_pgsql mbstring zip gd exif gettext \
        && pecl install redis && docker-php-ext-enable redis \
        && apk del $PHPIZE_DEPS && rm -rf /tmp/*
      COPY --from=composer:latest /usr/bin/composer /usr/bin/composer
      WORKDIR /app
      COPY . .
      RUN mkdir -p storage/framework/cache storage/framework/sessions storage/framework/views storage/logs bootstrap/cache \
        && cp .env.example .env \
        && composer install --no-interaction --no-ansi
      DOCKERFILE
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 1 : QUALITY (tous en parallele) ---
phpstan:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/phpstan analyse --memory-limit=512M
  rules:
    - if: $CI_COMMIT_BRANCH

style_check:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/pint --test
  rules:
    - if: $CI_COMMIT_BRANCH

composer_security:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE composer audit --abandoned=ignore
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 2 : BUILD & PUSH (en parall√®le avec tests) ---
build_image:
  stage: build_and_test
  needs: [phpstan, style_check, composer_security]
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - docker build --pull -t $APP_IMAGE:$IMAGE_TAG -t $APP_IMAGE:latest .
    - docker push $APP_IMAGE:$IMAGE_TAG
    - docker push $APP_IMAGE:latest
  after_script:
    - docker logout $CI_REGISTRY 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 2 : TESTS (en parall√®le avec build) ---
test_suite:
  stage: build_and_test
  needs: [prepare_ci_image]
  timeout: 10 minutes
  script:
    - docker network create ci-net-$CI_JOB_ID || true
    - |
      docker run -d --name pg-$CI_JOB_ID \
        --network ci-net-$CI_JOB_ID \
        --health-cmd="pg_isready -U gitlab -d testing" \
        --health-interval=2s \
        --health-timeout=5s \
        --health-retries=10 \
        -e POSTGRES_DB=testing \
        -e POSTGRES_USER=gitlab \
        -e POSTGRES_PASSWORD=test_pass \
        postgis/postgis:15-3.3-alpine
    # Wait for PostgreSQL container to be healthy (TCP ready)
    - |
      echo "Waiting for PostgreSQL health check..."
      for i in $(seq 1 60); do
        STATUS=$(docker inspect --format='{{.State.Health.Status}}' pg-$CI_JOB_ID 2>/dev/null || echo "starting")
        if [ "$STATUS" = "healthy" ]; then
          echo "Health check passed, verifying TCP from network..."
          break
        fi
        if [ "$i" = "60" ]; then
          echo "PostgreSQL failed to become healthy after 60s"
          docker logs pg-$CI_JOB_ID 2>&1 | tail -20
          exit 1
        fi
        sleep 1
      done
    # Verify actual TCP connectivity from within the Docker network (PostGIS may restart after init)
    - |
      for i in $(seq 1 30); do
        if docker run --rm --network ci-net-$CI_JOB_ID postgis/postgis:15-3.3-alpine pg_isready -h pg-$CI_JOB_ID -U gitlab -d testing -q 2>/dev/null; then
          echo "PostgreSQL is accepting TCP connections on the network."
          break
        fi
        if [ "$i" = "30" ]; then
          echo "PostgreSQL not reachable via network after 30s"
          docker logs pg-$CI_JOB_ID 2>&1 | tail -20
          exit 1
        fi
        sleep 1
      done
    - |
      docker run --rm \
        --network ci-net-$CI_JOB_ID \
        -e DB_CONNECTION=pgsql \
        -e DB_HOST=pg-$CI_JOB_ID \
        -e DB_PORT=5432 \
        -e DB_DATABASE=testing \
        -e DB_USERNAME=gitlab \
        -e DB_PASSWORD=test_pass \
        -e SCOUT_DRIVER=null \
        $CI_IMAGE sh -c '
          set -e
          cp .env.example .env
          cp .env.example .env.testing
          rm -f database/data/cities.sql
          php artisan key:generate --env=testing
          php artisan migrate --env=testing --force
          set +e
          echo "=== RUNNING TESTS ==="
          php artisan test --env=testing -v 2>&1
          TEST_RC=$?
          echo "=== TESTS FINISHED WITH RC=$TEST_RC ==="
          exit $TEST_RC
        '
  after_script:
    - docker rm -f pg-$CI_JOB_ID 2>/dev/null || true
    - docker network rm ci-net-$CI_JOB_ID 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 3 : DEPLOIEMENT ---
production_deploy:
  stage: deploy
  needs: [build_image, test_suite]
  timeout: 15 minutes
  script:
    - mkdir -p /opt/keyhome/.docker/nginx/conf.d
    - cp docker-compose.yml /opt/keyhome/docker-compose.yml
    - cp -rf .docker/nginx/conf.d/. /opt/keyhome/.docker/nginx/conf.d/
    # Sync codebase to VPS for reference and manual artisan commands
    - |
      AUTHENTICATED_URL="https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
      if [ -d /opt/keyhome/codebase/.git ]; then
        cd /opt/keyhome/codebase
        git remote set-url origin "$AUTHENTICATED_URL"
        git fetch origin main && git reset --hard origin/main
      else
        git clone --depth 1 --branch main "$AUTHENTICATED_URL" /opt/keyhome/codebase
      fi
    - cd /opt/keyhome || exit 1
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - export FULL_IMAGE="${CI_REGISTRY_IMAGE}/app:main"
    - echo "üöÄ Deploying image $FULL_IMAGE"
    # Enable maintenance mode before deploy
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan down --retry=60 || true
    - echo "üì¶ Stopping existing containers..."
    - APP_IMAGE=$FULL_IMAGE docker compose down --remove-orphans || true
    - echo "üì• Pulling new image..."
    - APP_IMAGE=$FULL_IMAGE docker compose pull
    - echo "üîÑ Starting containers..."
    - APP_IMAGE=$FULL_IMAGE docker compose up -d --no-build
    # Wait for app container to be healthy
    - |
      echo "‚è≥ Waiting for containers to be ready..."
      for i in $(seq 1 60); do
        if APP_IMAGE=$FULL_IMAGE docker compose exec -T app php -v > /dev/null 2>&1; then
          echo "‚úÖ App container is ready"
          break
        fi
        if [ "$i" = "60" ]; then
          echo "‚ùå App container failed to start"
          APP_IMAGE=$FULL_IMAGE docker compose logs app --tail=50
          APP_IMAGE=$FULL_IMAGE docker compose ps -a
          exit 1
        fi
        sleep 2
      done
    # Clear cache BEFORE migrations to ensure fresh config is loaded
    - echo "üßπ Clearing cache before migrations..."
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize:clear
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan config:cache
    # Run migrations ‚Äî rollback container on failure
    - |
      echo "üóÑÔ∏è Running migrations..."
      if ! APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan migrate --force; then
        echo "‚ùå Migration failed ‚Äî rolling back..."
        APP_IMAGE=$FULL_IMAGE docker compose logs app --tail=30
        APP_IMAGE=$FULL_IMAGE docker compose down --remove-orphans || true
        exit 1
      fi
    - echo "‚ö° Optimizing..."
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan filament:assets
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app chmod +x resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app bash resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan storage:link || true
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan l5-swagger:generate || true
    # Disable maintenance mode
    - echo "‚úÖ Deployment complete, bringing app back up..."
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan up
  after_script:
    - docker logout $CI_REGISTRY 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# --- ETAPE 4 : SMOKE TEST POST-DEPLOIEMENT ---
smoke_test:
  stage: smoke_test
  needs: [production_deploy]
  timeout: 3 minutes
  script:
    - |
      # Utilise la variable CI/CD API_BASE_URL (√† d√©finir dans GitLab Settings > CI/CD > Variables)
      BASE_URL="${API_BASE_URL:-https://api.keyhome.neocraft.dev}"
      echo "üîç Running smoke tests on $BASE_URL..."

      # Test 1: Health check endpoint
      echo "‚Üí Testing health endpoint..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/up")
      if [ "$HTTP_CODE" != "200" ]; then
        echo "‚ùå Health check failed (HTTP $HTTP_CODE)"
        exit 1
      fi
      echo "  ‚úÖ Health check passed"

      # Test 2: API cities endpoint (public)
      echo "‚Üí Testing API endpoint..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/api/v1/cities")
      if [ "$HTTP_CODE" != "200" ]; then
        echo "‚ùå API endpoint failed (HTTP $HTTP_CODE)"
        exit 1
      fi
      echo "  ‚úÖ API endpoint passed"

      # Test 3: Documentation accessible
      echo "‚Üí Testing Swagger docs..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/api/documentation")
      if [ "$HTTP_CODE" != "200" ]; then
        echo "‚ö†Ô∏è  Swagger docs not accessible (HTTP $HTTP_CODE) - continuing anyway"
      else
        echo "  ‚úÖ Swagger docs accessible"
      fi

      # Test 4: Admin panel loads
      echo "‚Üí Testing Filament admin..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$BASE_URL/admin/login")
      if [ "$HTTP_CODE" != "200" ]; then
        echo "‚ùå Admin panel failed (HTTP $HTTP_CODE)"
        exit 1
      fi
      echo "  ‚úÖ Admin panel accessible"

      echo ""
      echo "‚úÖ All smoke tests passed!"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# --- ETAPE 5 : NOTIFICATIONS ---
notify_slack_success:
  stage: notify
  needs: [smoke_test]
  script:
    - |
      # Calculer la dur√©e approximative (CI_PIPELINE_CREATED_AT est ISO 8601)
      if [ -n "$CI_PIPELINE_CREATED_AT" ]; then
        CREATED_TS=$(date -d "$CI_PIPELINE_CREATED_AT" +%s 2>/dev/null || echo "")
        if [ -n "$CREATED_TS" ]; then
          DURATION_MIN=$(( ($(date +%s) - CREATED_TS) / 60 ))
        else
          DURATION_MIN="?"
        fi
      else
        DURATION_MIN="?"
      fi
      SHORT_SHA="${CI_COMMIT_SHA:0:8}"

      curl -sS -X POST -H 'Content-type: application/json' \
      --data "{
        \"attachments\": [{
          \"color\": \"#36a64f\",
          \"blocks\": [
            {
              \"type\": \"header\",
              \"text\": {\"type\": \"plain_text\", \"text\": \"‚úÖ D√©ploiement Backend R√©ussi\", \"emoji\": true}
            },
            {
              \"type\": \"section\",
              \"fields\": [
                {\"type\": \"mrkdwn\", \"text\": \"*Branche:*\n\`$CI_COMMIT_REF_NAME\`\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Commit:*\n\`$SHORT_SHA\`\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Auteur:*\n$GITLAB_USER_NAME\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Dur√©e:*\n~${DURATION_MIN}min\"}
              ]
            },
            {
              \"type\": \"section\",
              \"text\": {\"type\": \"mrkdwn\", \"text\": \"üìù _${CI_COMMIT_TITLE}_\"}
            },
            {
              \"type\": \"actions\",
              \"elements\": [
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"üîó Commit\"}, \"url\": \"$CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA\"},
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"üìä Pipeline\"}, \"url\": \"$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID\"},
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"üåê API\"}, \"url\": \"${API_BASE_URL:-https://api.keyhome.neocraft.dev}/up\"}
              ]
            }
          ]
        }]
      }" $SLACK_WEBHOOK_URL
  when: on_success
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

notify_slack_failure:
  stage: notify
  needs:
    - job: smoke_test
      optional: true
    - job: production_deploy
      optional: true
    - job: test_suite
      optional: true
    - job: phpstan
      optional: true
    - job: style_check
      optional: true
  script:
    - |
      SHORT_SHA="${CI_COMMIT_SHA:0:8}"

      # R√©cup√©rer le vrai job qui a √©chou√© via l'API GitLab
      FAILED_JOBS_JSON=$(curl -sS --header "JOB-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/jobs?scope[]=failed" 2>/dev/null || echo "[]")

      # Extraire le premier job √©chou√© (sans jq, avec grep/sed)
      FAILED_JOB=$(echo "$FAILED_JOBS_JSON" | grep -o '"name":"[^"]*"' | head -1 | sed 's/"name":"//;s/"//' || echo "unknown")
      FAILED_STAGE=$(echo "$FAILED_JOBS_JSON" | grep -o '"stage":"[^"]*"' | head -1 | sed 's/"stage":"//;s/"//' || echo "unknown")

      # Fallback si l'API ne retourne rien
      [ -z "$FAILED_JOB" ] && FAILED_JOB="Voir la pipeline"
      [ -z "$FAILED_STAGE" ] && FAILED_STAGE="unknown"

      curl -sS -X POST -H 'Content-type: application/json' \
      --data "{
        \"attachments\": [{
          \"color\": \"#dc3545\",
          \"blocks\": [
            {
              \"type\": \"header\",
              \"text\": {\"type\": \"plain_text\", \"text\": \"üö® Pipeline Backend √âchou√©e\", \"emoji\": true}
            },
            {
              \"type\": \"section\",
              \"fields\": [
                {\"type\": \"mrkdwn\", \"text\": \"*√âtape √©chou√©e:*\n\`$FAILED_STAGE\`\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Job:*\n\`$FAILED_JOB\`\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Branche:*\n\`$CI_COMMIT_REF_NAME\`\"},
                {\"type\": \"mrkdwn\", \"text\": \"*Auteur:*\n$GITLAB_USER_NAME\"}
              ]
            },
            {
              \"type\": \"section\",
              \"text\": {\"type\": \"mrkdwn\", \"text\": \"üìù _${CI_COMMIT_TITLE}_\"}
            },
            {
              \"type\": \"actions\",
              \"elements\": [
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"üî¥ Voir l'erreur\"}, \"style\": \"danger\", \"url\": \"$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID\"},
                {\"type\": \"button\", \"text\": {\"type\": \"plain_text\", \"text\": \"üìã Logs\"}, \"url\": \"$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID/failures\"}
              ]
            }
          ]
        }]
      }" $SLACK_WEBHOOK_URL
  when: on_failure
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 6 : NETTOYAGE INTELLIGENT ---
cleanup:
  stage: cleanup
  script:
    - |
      echo "üßπ Starting cleanup..."

      # 1. Supprimer l'image CI de ce pipeline
      if docker images -q $CI_IMAGE 2>/dev/null | grep -q .; then
        docker rmi $CI_IMAGE && echo "  ‚úì Removed CI image: $CI_IMAGE"
      fi

      # 2. Nettoyer les images dangling (sans tag)
      DANGLING=$(docker images -f "dangling=true" -q 2>/dev/null | wc -l | tr -d ' ')
      if [ "$DANGLING" -gt 0 ]; then
        docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || true
        echo "  ‚úì Removed $DANGLING dangling images"
      fi

      # 3. Nettoyer les containers arr√™t√©s depuis plus de 1h
      STOPPED=$(docker ps -a -f "status=exited" --format '{{.ID}}' 2>/dev/null | wc -l | tr -d ' ')
      if [ "$STOPPED" -gt 0 ]; then
        docker container prune -f --filter "until=1h" 2>/dev/null
        echo "  ‚úì Cleaned stopped containers"
      fi

      # 4. Nettoyer les networks orphelins (sauf ceux en cours d'utilisation)
      docker network prune -f --filter "until=1h" 2>/dev/null || true
      echo "  ‚úì Cleaned unused networks"

      # 5. Nettoyer les volumes orphelins (attention: pas les donn√©es!)
      # docker volume prune -f --filter "label!=keep" 2>/dev/null || true

      # 6. Nettoyer le build cache Docker (garde 10GB)
      docker builder prune -f --keep-storage=10GB 2>/dev/null || true
      echo "  ‚úì Cleaned build cache (keeping 10GB)"

      # 7. Rapport final
      echo ""
      echo "üìä Disk usage after cleanup:"
      docker system df 2>/dev/null || true
  when: always
  rules:
    - if: $CI_COMMIT_BRANCH
