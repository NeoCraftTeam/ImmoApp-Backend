stages:
  - prepare
  - quality
  - build
  - test
  - deploy
  - notify
  - cleanup

variables:
  APP_IMAGE: $CI_REGISTRY_IMAGE/app
  IMAGE_TAG: $CI_COMMIT_REF_SLUG
  CI_IMAGE: keyhome-ci:$CI_COMMIT_SHORT_SHA

default:
  tags:
    - self-hosted-shell

# --- ETAPE 0 : BUILD IMAGE CI (une seule fois) ---
prepare_ci_image:
  stage: prepare
  script:
    - |
      docker build -t $CI_IMAGE -f - . <<'DOCKERFILE'
      FROM php:8.4-cli-alpine
      RUN apk add --no-cache git libzip-dev icu-dev postgresql-dev libpng-dev oniguruma-dev gettext-dev freetype-dev libjpeg-turbo-dev libwebp-dev $PHPIZE_DEPS \
        && docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp \
        && docker-php-ext-install bcmath intl pdo_pgsql mbstring zip gd exif gettext \
        && pecl install redis && docker-php-ext-enable redis \
        && apk del $PHPIZE_DEPS && rm -rf /tmp/*
      COPY --from=composer:latest /usr/bin/composer /usr/bin/composer
      WORKDIR /app
      COPY . .
      RUN composer install --no-interaction --no-ansi
      DOCKERFILE
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 1 : QUALITY (tous en parallele) ---
phpstan:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/phpstan analyse --memory-limit=512M
  rules:
    - if: $CI_COMMIT_BRANCH

style_check:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/pint --test
  rules:
    - if: $CI_COMMIT_BRANCH

composer_security:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE composer audit --abandoned=ignore
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 2 : BUILD & PUSH (prod image) ---
build_image:
  stage: build
  needs: [phpstan, style_check, composer_security]
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - docker build --pull -t $APP_IMAGE:$IMAGE_TAG .
    - docker push $APP_IMAGE:$IMAGE_TAG
    - docker logout $CI_REGISTRY
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 3 : TESTS ---
test_suite:
  stage: test
  needs: [prepare_ci_image]
  script:
    - docker network create ci-net-$CI_JOB_ID || true
    - |
      docker run -d --name pg-$CI_JOB_ID \
        --network ci-net-$CI_JOB_ID \
        -e POSTGRES_DB=testing \
        -e POSTGRES_USER=gitlab \
        -e POSTGRES_PASSWORD=test_pass \
        postgis/postgis:16-3.5-alpine
    - sleep 5
    - |
      docker run --rm \
        --network ci-net-$CI_JOB_ID \
        -e DB_CONNECTION=pgsql \
        -e DB_HOST=pg-$CI_JOB_ID \
        -e DB_PORT=5432 \
        -e DB_DATABASE=testing \
        -e DB_USERNAME=gitlab \
        -e DB_PASSWORD=test_pass \
        $CI_IMAGE sh -c "
          cp .env.example .env.testing &&
          php artisan key:generate --env=testing &&
          php artisan migrate --env=testing --force &&
          php artisan test --env=testing
        "
  after_script:
    - docker rm -f pg-$CI_JOB_ID 2>/dev/null || true
    - docker network rm ci-net-$CI_JOB_ID 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 4 : DEPLOIEMENT ---
production_deploy:
  stage: deploy
  needs: [build_image, test_suite]
  script:
    - mkdir -p /opt/keyhome/.docker/nginx/conf.d
    - cp docker-compose.yml /opt/keyhome/docker-compose.yml
    - cp -rf .docker/nginx/conf.d/. /opt/keyhome/.docker/nginx/conf.d/
    - cd /opt/keyhome || exit 1
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - export FULL_IMAGE="${CI_REGISTRY_IMAGE}/app:main"
    - APP_IMAGE=$FULL_IMAGE docker compose down --remove-orphans || true
    - APP_IMAGE=$FULL_IMAGE docker compose pull
    - APP_IMAGE=$FULL_IMAGE docker compose up -d --no-build
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan migrate --force
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize:clear
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan filament:upgrade
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app chmod +x resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app bash resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan storage:link || true
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan l5-swagger:generate || true
    - docker logout $CI_REGISTRY
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# --- ETAPE 5 : NOTIFICATIONS ---
notify_slack_success:
  stage: notify
  needs: [production_deploy]
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
      --data "{
        \"text\": \"‚úÖ *[BACKEND] D√©ploiement R√©ussi !*\n\n*Auteur:* $GITLAB_USER_NAME\n*Branche:* \`$CI_COMMIT_REF_NAME\`\n*Message:* _${CI_COMMIT_TITLE}_\n\nüîó <$CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA|Voir le commit> | <$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID|Voir la pipeline>\"
      }" $SLACK_WEBHOOK_URL
  when: on_success
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

notify_slack_failure:
  stage: notify
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
      --data "{
        \"text\": \"‚ùå *[BACKEND] √âchec de la Pipeline !*\n\n*√âtape:* \`$CI_JOB_STAGE\`\n*Auteur:* $GITLAB_USER_NAME\n*Branche:* \`$CI_COMMIT_REF_NAME\`\n\nüö® <$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID|V√©rifier l'erreur imm√©diatement>\"
      }" $SLACK_WEBHOOK_URL
  when: on_failure
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 6 : NETTOYAGE ---
cleanup:
  stage: cleanup
  script:
    - docker rmi $CI_IMAGE 2>/dev/null || true
    - docker system prune -f
  when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
