stages:
  - prepare
  - quality
  - build
  - test
  - deploy
  - notify
  - cleanup

variables:
  APP_IMAGE: $CI_REGISTRY_IMAGE/app
  IMAGE_TAG: $CI_COMMIT_REF_SLUG
  CI_IMAGE: keyhome-ci:$CI_COMMIT_SHORT_SHA

default:
  tags:
    - self-hosted-shell

# --- ETAPE 0 : BUILD IMAGE CI (une seule fois) ---
prepare_ci_image:
  stage: prepare
  script:
    - |
      docker build -t $CI_IMAGE -f - . <<'DOCKERFILE'
      FROM php:8.4-cli-alpine
      RUN apk add --no-cache git libzip-dev icu-dev postgresql-dev libpng-dev oniguruma-dev gettext-dev freetype-dev libjpeg-turbo-dev libwebp-dev $PHPIZE_DEPS \
        && docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp \
        && docker-php-ext-install bcmath intl pdo_pgsql mbstring zip gd exif gettext \
        && pecl install redis && docker-php-ext-enable redis \
        && apk del $PHPIZE_DEPS && rm -rf /tmp/*
      COPY --from=composer:latest /usr/bin/composer /usr/bin/composer
      WORKDIR /app
      COPY . .
      RUN mkdir -p storage/framework/cache storage/framework/sessions storage/framework/views storage/logs bootstrap/cache \
        && cp .env.example .env \
        && composer install --no-interaction --no-ansi
      DOCKERFILE
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 1 : QUALITY (tous en parallele) ---
phpstan:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/phpstan analyse --memory-limit=512M
  rules:
    - if: $CI_COMMIT_BRANCH

style_check:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE ./vendor/bin/pint --test
  rules:
    - if: $CI_COMMIT_BRANCH

composer_security:
  stage: quality
  needs: [prepare_ci_image]
  script:
    - docker run --rm $CI_IMAGE composer audit --abandoned=ignore
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 2 : BUILD & PUSH (prod image) ---
build_image:
  stage: build
  needs: [phpstan, style_check, composer_security]
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - docker build --pull -t $APP_IMAGE:$IMAGE_TAG -t $APP_IMAGE:latest .
    - docker push $APP_IMAGE:$IMAGE_TAG
    - docker push $APP_IMAGE:latest
  after_script:
    - docker logout $CI_REGISTRY 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 3 : TESTS ---
test_suite:
  stage: test
  needs: [prepare_ci_image]
  timeout: 10 minutes
  script:
    - docker network create ci-net-$CI_JOB_ID || true
    - |
      docker run -d --name pg-$CI_JOB_ID \
        --network ci-net-$CI_JOB_ID \
        --health-cmd="pg_isready -U gitlab -d testing" \
        --health-interval=2s \
        --health-timeout=5s \
        --health-retries=10 \
        -e POSTGRES_DB=testing \
        -e POSTGRES_USER=gitlab \
        -e POSTGRES_PASSWORD=test_pass \
        postgis/postgis:15-3.3-alpine
    # Wait for PostgreSQL container to be healthy (TCP ready)
    - |
      echo "Waiting for PostgreSQL..."
      for i in $(seq 1 60); do
        STATUS=$(docker inspect --format='{{.State.Health.Status}}' pg-$CI_JOB_ID 2>/dev/null || echo "starting")
        if [ "$STATUS" = "healthy" ]; then
          echo "PostgreSQL is healthy."
          break
        fi
        if [ "$i" = "60" ]; then
          echo "PostgreSQL failed to become healthy after 60s"
          docker logs pg-$CI_JOB_ID 2>&1 | tail -20
          exit 1
        fi
        sleep 1
      done
    - |
      docker run --rm \
        --network ci-net-$CI_JOB_ID \
        -e DB_CONNECTION=pgsql \
        -e DB_HOST=pg-$CI_JOB_ID \
        -e DB_PORT=5432 \
        -e DB_DATABASE=testing \
        -e DB_USERNAME=gitlab \
        -e DB_PASSWORD=test_pass \
        -e SCOUT_DRIVER=null \
        $CI_IMAGE sh -c '
          set -e
          cp .env.example .env
          cp .env.example .env.testing
          rm -f database/data/cities.sql
          php artisan key:generate --env=testing
          php artisan migrate --env=testing --force
          set +e
          echo "=== RUNNING TESTS ==="
          php artisan test --env=testing -v 2>&1
          TEST_RC=$?
          echo "=== TESTS FINISHED WITH RC=$TEST_RC ==="
          exit $TEST_RC
        '
  after_script:
    - docker rm -f pg-$CI_JOB_ID 2>/dev/null || true
    - docker network rm ci-net-$CI_JOB_ID 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 4 : DEPLOIEMENT ---
production_deploy:
  stage: deploy
  needs: [build_image, test_suite]
  timeout: 15 minutes
  script:
    - mkdir -p /opt/keyhome/.docker/nginx/conf.d
    - cp docker-compose.yml /opt/keyhome/docker-compose.yml
    - cp -rf .docker/nginx/conf.d/. /opt/keyhome/.docker/nginx/conf.d/
    # Sync codebase to VPS for reference and manual artisan commands
    - |
      if [ -d /opt/keyhome/codebase/.git ]; then
        cd /opt/keyhome/codebase && git fetch origin main && git reset --hard origin/main
      else
        git clone --depth 1 --branch main "$CI_REPOSITORY_URL" /opt/keyhome/codebase
      fi
    - cd /opt/keyhome || exit 1
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - export FULL_IMAGE="${CI_REGISTRY_IMAGE}/app:main"
    # Enable maintenance mode before deploy
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan down --retry=60 || true
    - APP_IMAGE=$FULL_IMAGE docker compose down --remove-orphans || true
    - APP_IMAGE=$FULL_IMAGE docker compose pull
    - APP_IMAGE=$FULL_IMAGE docker compose up -d --no-build
    # Run migrations ‚Äî rollback container on failure
    - |
      if ! APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan migrate --force; then
        echo "Migration failed ‚Äî rolling back..."
        APP_IMAGE=$FULL_IMAGE docker compose down --remove-orphans || true
        exit 1
      fi
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize:clear
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan optimize
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app chmod +x resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app bash resetFilamentLivewire.sh
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan storage:link || true
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan l5-swagger:generate || true
    # Disable maintenance mode
    - APP_IMAGE=$FULL_IMAGE docker compose exec -T app php artisan up
  after_script:
    - docker logout $CI_REGISTRY 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# --- ETAPE 5 : NOTIFICATIONS ---
notify_slack_success:
  stage: notify
  needs: [production_deploy]
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
      --data "{
        \"text\": \"‚úÖ *[BACKEND] D√©ploiement R√©ussi !*\n\n*Auteur:* $GITLAB_USER_NAME\n*Branche:* \`$CI_COMMIT_REF_NAME\`\n*Message:* _${CI_COMMIT_TITLE}_\n\nüîó <$CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA|Voir le commit> | <$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID|Voir la pipeline>\"
      }" $SLACK_WEBHOOK_URL
  when: on_success
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

notify_slack_failure:
  stage: notify
  needs:
    - job: production_deploy
      optional: true
    - job: test_suite
      optional: true
    - job: phpstan
      optional: true
    - job: style_check
      optional: true
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
      --data "{
        \"text\": \"‚ùå *[BACKEND] √âchec de la Pipeline !*\n\n*√âtape:* \`$CI_JOB_STAGE\`\n*Auteur:* $GITLAB_USER_NAME\n*Branche:* \`$CI_COMMIT_REF_NAME\`\n\nüö® <$CI_PROJECT_URL/-/pipelines/$CI_PIPELINE_ID|V√©rifier l'erreur imm√©diatement>\"
      }" $SLACK_WEBHOOK_URL
  when: on_failure
  rules:
    - if: $CI_COMMIT_BRANCH

# --- ETAPE 6 : NETTOYAGE ---
cleanup:
  stage: cleanup
  script:
    - docker rmi $CI_IMAGE 2>/dev/null || true
    - docker system prune -f --filter "until=24h"
  when: always
  rules:
    - if: $CI_COMMIT_BRANCH
