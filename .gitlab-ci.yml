# Pipeline GitLab CI/CD DevOps pour Laravel - Production uniquement

include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml

stages:
  - build
  - test
  - security
  - deploy
  - verify

variables:
  # Variables PostgreSQL pour les tests
  POSTGRES_DB: laravel_test
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: secret
  DB_HOST: postgres
  DB_CONNECTION: pgsql
  # Variables pour SAST
  SAST_EXCLUDED_PATHS: "spec,test,tests,tmp,vendor"

# ==========================================
# STAGE: BUILD - Compilation des assets (si vous utilisez npm/vite)
# ==========================================
build:assets:
  stage: build
  image: node:20
  cache:
    key: ${CI_COMMIT_REF_SLUG}-npm
    paths:
      - node_modules/
  script:
    - echo "üì¶ Installation des d√©pendances npm..."
    - npm ci
    - echo "üèóÔ∏è Build des assets..."
    - npm run build
  artifacts:
    paths:
      - public/build/
    expire_in: 1 day
  only:
    - main
  # Commentez ce job entier si vous n'utilisez pas npm/Vite

# ==========================================
# STAGE: TEST - Tests automatis√©s
# ==========================================
test:keyhome:
  stage: test
  image: php:8.4-fpm
  services:
    - name: postgis/postgis:15-3.3
      alias: postgres
  variables:
    DB_CONNECTION: pgsql
    DB_HOST: postgres
    DB_PORT: 5432
    DB_DATABASE: laravel_test
    DB_USERNAME: postgres
    DB_PASSWORD: secret
  cache:
    key: ${CI_COMMIT_REF_SLUG}-composer
    paths:
      - vendor/
  before_script:
    - echo "üîß Installation des d√©pendances syst√®me..."
    - apt-get update -qq && apt-get install -y -qq git curl libzip-dev libpq-dev unzip libicu-dev
    - docker-php-ext-configure intl
    - docker-php-ext-install pdo_pgsql pgsql zip intl exif

    - echo "üì• Installation de Composer..."
    - curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

    - echo "üì¶ Installation des d√©pendances Laravel..."
    - composer install --prefer-dist --no-ansi --no-interaction --no-progress

    - echo "‚öôÔ∏è Configuration de l'environnement de test..."
    - cp .env.example .env
    - php artisan key:generate
    - echo "DB_CONNECTION=pgsql" >> .env
    - echo "DB_HOST=postgres" >> .env
    - echo "DB_PORT=5432" >> .env
    - echo "DB_DATABASE=laravel_test" >> .env
    - echo "DB_USERNAME=postgres" >> .env
    - echo "DB_PASSWORD=secret" >> .env
    - php artisan config:clear

  script:
    - echo "üóÑÔ∏è Ex√©cution des migrations..."
    - php artisan migrate --force

    - echo "üß™ Lancement des tests..."
    - php artisan test

  only:
    - main
    - merge_requests

# ==========================================
# STAGE: DEPLOY - D√©ploiement en Production
# ==========================================
deploy:production:
  stage: deploy
  image: alpine:latest
  needs:
    - test:keyhome
    # - build:assets # D√©commentez si vous utilisez npm
  before_script:
    - echo "üîê Configuration SSH..."
    - apk add --no-cache openssh-client git curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - echo "üöÄ D√©but du d√©ploiement sur $VPS_HOST..."
    - |
      ssh $VPS_USER@$VPS_HOST "
        set -e

        echo '================================================'
        echo 'üöÄ D√âPLOIEMENT PRODUCTION - Pipeline #$CI_PIPELINE_ID'
        echo '================================================'

        cd $VPS_PATH

        # Sauvegarder le commit actuel pour rollback √©ventuel
        CURRENT_COMMIT=\$(git rev-parse HEAD 2>/dev/null || echo 'unknown')
        echo \$CURRENT_COMMIT > /tmp/last_commit_keyhome.txt
        echo \"üìå Commit actuel sauvegard√©: \$CURRENT_COMMIT\"

        # Backup de la base de donn√©es
        echo ''
        echo 'üíæ Backup de la base de donn√©es...'
        BACKUP_DIR=/var/backups/keyhome
        mkdir -p \$BACKUP_DIR
        BACKUP_FILE=\$BACKUP_DIR/db_\$(date +%Y%m%d_%H%M%S).sql

        # Utilise les variables du .env local
        php artisan db:backup 2>/dev/null || pg_dump \$(grep DB_DATABASE .env | cut -d '=' -f2) > \$BACKUP_FILE 2>/dev/null || echo '‚ö†Ô∏è Backup √©chou√© (normal si premi√®re fois)'

        if [ -f \$BACKUP_FILE ]; then
          gzip \$BACKUP_FILE
          echo \"‚úÖ Backup cr√©√©: \$BACKUP_FILE.gz\"

          # Garder seulement les 10 derniers backups
          ls -t \$BACKUP_DIR/db_*.sql.gz 2>/dev/null | tail -n +11 | xargs -r rm
          echo \"üóëÔ∏è Anciens backups nettoy√©s\"
        fi

        # Mode maintenance
        echo ''
        echo 'üîí Mise en mode maintenance...'
        php artisan down --retry=60 --refresh=15 || true

        # Mise √† jour du code
        echo ''
        echo 'üì• R√©cup√©ration du code (commit: $CI_COMMIT_SHORT_SHA)...'
        git fetch origin main
        git reset --hard origin/main
        NEW_COMMIT=\$(git rev-parse HEAD)
        echo \"‚úÖ Code mis √† jour vers: \$NEW_COMMIT\"

        # Installation des d√©pendances
        echo ''
        echo 'üì¶ Installation des d√©pendances Composer...'
        composer install --no-dev --optimize-autoloader --no-interaction --quiet

        # Nettoyage des caches
        echo ''
        echo 'üßπ Nettoyage des caches...'
        php artisan cache:clear
        php artisan config:clear
        php artisan route:clear
        php artisan view:clear

        # V√©rification PostGIS
        echo ''
        echo 'üó∫Ô∏è V√©rification de PostGIS...'
        php artisan db:check-postgis 2>/dev/null || echo 'PostGIS d√©j√† configur√©'

        # Migrations
        echo ''
        echo 'üóÑÔ∏è Ex√©cution des migrations...'
        php artisan migrate --force

        # Publication des assets Livewire et Filament
        echo ''
        echo 'üì¶ Publication des assets...'
        php artisan vendor:publish --force --tag=livewire:assets --ansi --no-interaction
        php artisan filament:assets

        # Optimisations pour la production
        echo ''
        echo '‚ö° Optimisations...'
        php artisan config:cache
        php artisan route:cache
        php artisan view:cache
        php artisan event:cache
        php artisan filament:cache-components

        # Permissions des fichiers
        echo ''
        echo 'üîí Configuration des permissions...'
        chmod -R 775 storage bootstrap/cache
        chown -R www-data:www-data storage bootstrap/cache

        # Red√©marrage des workers Queue (si utilis√©)
        echo ''
        echo 'üîÑ Red√©marrage des workers...'
        php artisan queue:restart 2>/dev/null || echo 'Pas de workers √† red√©marrer'

        # Fin du mode maintenance
        echo ''
        echo '‚úÖ Sortie du mode maintenance...'
        php artisan up

        echo ''
        echo '================================================'
        echo '‚úÖ D√âPLOIEMENT TERMIN√â AVEC SUCC√àS!'
        echo '================================================'
        echo \"Commit d√©ploy√©: \$NEW_COMMIT\"
        echo \"Pipeline: #$CI_PIPELINE_ID\"
        echo \"Par: $GITLAB_USER_LOGIN\"
        echo \"Date: \$(date)\"
      "

  environment:
    name: production
    url: https://votre-domaine.com

  only:
    - main

  when: manual  # Changez en "on_success" pour d√©ploiement automatique

# ==========================================
# STAGE: VERIFY - V√©rification post-d√©ploiement
# ==========================================
verify:health-check:
  stage: verify
  image: alpine:latest
  needs:
    - deploy:production
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üè• V√©rification de l'application..."
    - sleep 10
    - |
      echo "Test de la page d'accueil..."
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://votre-domaine.com || echo "000")

      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
        echo "‚úÖ Application accessible! (HTTP $HTTP_CODE)"
      else
        echo "‚ùå ERREUR: Application inaccessible (HTTP $HTTP_CODE)"
        echo "‚ö†Ô∏è V√©rifiez manuellement ou lancez le rollback!"
        exit 1
      fi

      # Test de l'API health endpoint (cr√©ez-le dans votre app)
      echo ""
      echo "Test de l'API health..."
      API_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://votre-domaine.com/api/health 2>/dev/null || echo "404")

      if [ "$API_CODE" = "200" ]; then
        echo "‚úÖ API Health OK!"
      else
        echo "‚ö†Ô∏è API Health endpoint introuvable (cr√©ez /api/health)"
      fi

      echo ""
      echo "‚úÖ V√©rifications termin√©es!"

  only:
    - main

  allow_failure: true  # Ne bloque pas si le health check √©choue

# ==========================================
# MONITORING - Installation Sentry (optionnel)
# ==========================================
setup:monitoring:
  stage: verify
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
  script:
    - |
      ssh $VPS_USER@$VPS_HOST "
        cd $VPS_PATH

        # V√©rifier si Sentry est configur√©
        if grep -q 'SENTRY_LARAVEL_DSN' .env; then
          echo '‚úÖ Sentry d√©j√† configur√©'
        else
          echo '‚ö†Ô∏è Sentry non configur√©. Ajoutez SENTRY_LARAVEL_DSN dans votre .env'
          echo 'üìù Installation: composer require sentry/sentry-laravel'
        fi

        # V√©rifier Laravel Telescope (dev only)
        if php artisan | grep -q telescope; then
          echo '‚úÖ Telescope install√©'
        else
          echo 'üí° Conseil: Installez Laravel Telescope pour le debug'
        fi
      "
  when: manual
  only:
    - main

# ==========================================
# NOTIFICATIONS - Slack/Discord (optionnel)
# ==========================================
notify:success:
  stage: verify
  image: curlimages/curl:latest
  script:
    - |
      if [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚úÖ D√©ploiement r√©ussi!\",
            \"attachments\": [{
              \"color\": \"good\",
              \"fields\": [
                {\"title\": \"Projet\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
                {\"title\": \"Branche\", \"value\": \"$CI_COMMIT_REF_NAME\", \"short\": true},
                {\"title\": \"Commit\", \"value\": \"$CI_COMMIT_SHORT_SHA\", \"short\": true},
                {\"title\": \"Par\", \"value\": \"$GITLAB_USER_LOGIN\", \"short\": true},
                {\"title\": \"Pipeline\", \"value\": \"#$CI_PIPELINE_ID\", \"short\": true},
                {\"title\": \"URL\", \"value\": \"https://votre-domaine.com\", \"short\": true}
              ]
            }]
          }"
        echo "‚úÖ Notification Slack envoy√©e"
      else
        echo "‚ÑπÔ∏è SLACK_WEBHOOK_URL non configur√© - notifications d√©sactiv√©es"
      fi
  needs:
    - deploy:production
  when: on_success
  only:
    - main
  allow_failure: true

notify:failure:
  stage: verify
  image: curlimages/curl:latest
  script:
    - |
      if [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST "$SLACK_WEBHOOK_URL" \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"‚ùå D√©ploiement √©chou√©!\",
            \"attachments\": [{
              \"color\": \"danger\",
              \"fields\": [
                {\"title\": \"Projet\", \"value\": \"$CI_PROJECT_NAME\", \"short\": true},
                {\"title\": \"Branche\", \"value\": \"$CI_COMMIT_REF_NAME\", \"short\": true},
                {\"title\": \"Pipeline\", \"value\": \"#$CI_PIPELINE_ID\", \"short\": true},
                {\"title\": \"Lien\", \"value\": \"$CI_PIPELINE_URL\", \"short\": false}
              ]
            }]
          }"
        echo "‚úÖ Notification d'√©chec envoy√©e"
      fi
  needs:
    - deploy:production
  when: on_failure
  only:
    - main
  allow_failure: true

# ==========================================
# ROLLBACK - En cas de probl√®me
# ==========================================
rollback:production:
  stage: verify
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client git
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $VPS_HOST >> ~/.ssh/known_hosts
  script:
    - echo "üîô ROLLBACK EN COURS..."
    - |
      ssh $VPS_USER@$VPS_HOST "
        set -e

        echo '================================================'
        echo 'üîô ROLLBACK PRODUCTION'
        echo '================================================'

        cd $VPS_PATH

        php artisan down || true

        # Retour au commit pr√©c√©dent
        if [ -f /tmp/last_commit_keyhome.txt ]; then
          LAST_COMMIT=\$(cat /tmp/last_commit_keyhome.txt)
          echo \"Retour au commit: \$LAST_COMMIT\"
          git reset --hard \$LAST_COMMIT
        else
          echo \"‚ö†Ô∏è Pas de commit pr√©c√©dent trouv√©\"
          git reset --hard HEAD~1
        fi

        # R√©installer les d√©pendances
        composer install --no-dev --optimize-autoloader --no-interaction

        # Rollback des migrations (ATTENTION: peut causer des pertes de donn√©es)
        echo '‚ö†Ô∏è Rollback des migrations (derni√®re migration uniquement)...'
        php artisan migrate:rollback --step=1 --force

        # R√©-optimiser
        php artisan optimize

        # Remettre en ligne
        php artisan up

        echo ''
        echo '‚úÖ ROLLBACK TERMIN√â'
        echo 'V√©rifiez que tout fonctionne correctement!'
      "

  when: manual
  only:
    - main

  environment:
    name: production
    action: rollback
